# JavaScript / TypeScript コーディングガイドライン（推奨）

JS/TS 共通の推奨方針。

## 基本構文

- const を優先、再代入が必要な場合のみ let（var は使用しない）
- 厳密等価演算子（`===` / `!==`）を使う
- 早期リターンでネストを減らす
- 文字列に変数を埋め込む場合はテンプレートリテラルを優先

## null/undefined

- Optional chaining（?.）と Nullish coalescing（??）を活用
- null と undefined を理由なく混在させない（API・ライブラリ由来は例外）
- 空オブジェクト `{}` を「値なし」として扱わない

## 非同期処理・エラー

- Promise チェーンより async/await を優先
- try/catch はシステム境界で使う（外部API・Webhook検証・クライアント↔サーバー）
- 「throw して即 catch」は戻り値ベース（safeParse 等）に置き換える
- 文字列でなく Error オブジェクトを throw

## 配列・オブジェクト

- 破壊的メソッドより非破壊的操作を優先（性能要件がある場合は例外）
- 存在チェックは明示的に（`arr.length > 0`、`Object.keys(obj).length > 0`）
- ショートハンド `{ name }` と分割代入を活用
- ミュータブルなオブジェクトのスコープは最小限に

## モジュール

- export default より named export を優先

## 型の書き方

- 関数の引数・戻り値は型注釈を付ける（export は必須）
- 内部関数・ローカル変数は推論に任せる（境界・空配列・状態の初期値は例外）
- any より unknown、型アサーション（as）や Non-null assertion（!）は最終手段
- 型の絞り込み（typeof, instanceof, in, 型ガード関数）を活用
- as const と Utility Types を活用

## 型の配置

- 型はそれを使うコードに最も近い場所に定義し、必要になるまで export しない
- 昇格の基準は「使用箇所の数」ではなく「レイヤー境界を超えるか」
- 型の所有者は、その形状を決定するレイヤー（生成元）

| 使用範囲             | 配置                 | export         |
| -------------------- | -------------------- | -------------- |
| 1 ファイル内         | そのファイル内       | しない         |
| 同一レイヤー内       | レイヤー内のファイル | レイヤー内のみ |
| レイヤー境界を超える | 共有ディレクトリ     | する           |

### 昇格しない例

- 同じ Props 型を複数のコンポーネントで使う → 同一レイヤー内に留める
- データアクセス層の内部型を複数の関数で使う → そのレイヤー内に留める

## ブランデッドタイプ

- Branded 型を使い、プリミティブに意味を付与する
- 生成箇所で `asXxx()` ヘルパーを通して branded 化する
- ユーザー入力が発生する場合はバリデーション後に昇格する
- 型定義とヘルパーはコロケーション原則に従って配置する

## JSDoc（テスト対象の純粋関数）

テスト対象の純粋関数には仕様レベルの JSDoc を記述する。
テストと JSDoc から実装が一意に理解できることを目標とする。

### 記述項目

| 項目         | 内容                                       |
| ------------ | ------------------------------------------ |
| 概要         | この関数が「何を計算するか」（仕様レベル） |
| `@param`     | 入力値の意味・制約・前提条件               |
| `@returns`   | 出力値の意味                               |
| エッジケース | null / 0 / 空配列 / 境界値の振る舞い       |
| 設計判断     | なぜこの仕様なのか（必要な場合のみ）       |

### 方針

- 「コードの説明」ではなく「仕様の説明」を書く
- JSDoc に書いていない仕様を暗黙的に実装しない
- UI コンポーネントや薄いラッパーには不要（純粋関数のみ対象）
